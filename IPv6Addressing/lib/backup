

#include <arpa/inet.h>        // inet_pton() and inet_ntop()
/// Offset of data from start of frame
#define PKT_OFFSET      (TPACKET_ALIGN(sizeof(struct tpacket_hdr)) + \
                         TPACKET_ALIGN(sizeof(struct sockaddr_ll)))

static int ring_offset;

static int sd_rcv;
static struct udppacket *packetinfo;
static char *ring;



// tp_block_size must be a multiple of PAGE_SIZE (1)
// tp_frame_size must be greater than TPACKET_HDRLEN (obvious)
// tp_frame_size must be a multiple of TPACKET_ALIGNMENT
// tp_frame_nr   must be exactly frames_per_block*tp_block_nr

/// Initialize a packet socket ring buffer
//  @param ringtype is one of PACKET_RX_RING or PACKET_TX_RING
int init_packetsock_ring_rx(){
    struct tpacket_req tp;

    // tell kernel to export data through mmap()ped ring
    tp.tp_block_size = BLOCKSIZE;
    tp.tp_block_nr = CONF_RING_BLOCKS;
    tp.tp_frame_size = FRAMESIZE;
    tp.tp_frame_nr = CONF_RING_BLOCKS * (BLOCKSIZE/ FRAMESIZE);
    if (setsockopt(sd_rcv, SOL_PACKET, PACKET_RX_RING, (void*) &tp, sizeof(tp)))
        RETURN_ERROR(-1, "setsockopt() ring\n");
    #ifdef TPACKET_V2
    val = TPACKET_V1;
    setsockopt(sd_rcv, SOL_PACKET, PACKET_HDRLEN, &val, sizeof(val));
    #endif

    // open ring
    ring = mmap(0, tp.tp_block_size * tp.tp_block_nr,
               PROT_READ | PROT_WRITE, MAP_SHARED, sd_rcv, 0);
    if (!ring)
        RETURN_ERROR(-1, "mmap()\n");
    return EXIT_SUCCESS;
}

/// Create a packet socket. If param ring is not NULL, the buffer is mapped
//  @param ring will, if set, point to the mapped ring on return
//  @return the socket fd
static int init_packetsock() {

    // open packet socket
    sd_rcv = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sd_rcv < 0)
        RETURN_ERROR(-1, "Root privileges are required\nsocket() rx. \n");
    if (-1 == bind(sd_rcv, (struct sockaddr *)&packetinfo->device, sizeof(packetinfo->device))) {
        return EXIT_FAILURE;
    }
    init_packetsock_ring_rx();

    if (!ring) {
      close(sd_rcv);
        RETURN_ERROR(-1, "Ring initialisation failed!\n");
    }

  return EXIT_SUCCESS;
}

int close_rcv_socket_new() {
    if (munmap(ring, BLOCKSIZE)) {
        perror("munmap");
        return 1;
    }
    if (close(sd_rcv)) {
        perror("close");
        return 1;
    }
    return 0;
}

// Release the slot back to the kernel
static void process_rx_release(char *rx_ring) {
  struct tpacket_hdr *header;

  // clear status to grant to kernel
  header = (struct tpacket_hdr * )(char *) rx_ring + (ring_offset * FRAMESIZE);
  header->tp_status = 0;

  // update consumer pointer
  ring_offset = (ring_offset + 1) & (CONF_RING_FRAMES - 1);
}

/// Blocking read, returns a single packet (from packet ring)
static void *rcv_mmap() {
  struct tpacket_hdr *header;
  struct pollfd pollset;
  int ret;

  // fetch a frame
  header = (struct tpacket_hdr * )((char *) ring + (ring_offset * FRAMESIZE));
  //assert((((unsigned long) header) & (getpagesize() - 1)) == 0);

  // TP_STATUS_USER means that the process owns the packet.
  // When a slot does not have this flag set, the frame is not
  // ready for consumption.
  while (!(header->tp_status & TP_STATUS_USER)) {

    // if none available: wait on more data
    pollset.fd = sd_rcv;
    pollset.events = POLLIN;
    pollset.revents = 0;
    ret = poll(&pollset, 1, -1 /* negative means infinite */);
    if (ret < 0) {
      if (errno != EINTR)
        RETURN_ERROR(NULL, "poll()\n");
      return NULL;
    }
  }

  // check data
  if (header->tp_status & TP_STATUS_COPY)
    RETURN_ERROR(NULL, "skipped: incomplete packed\n");
  if (header->tp_status & TP_STATUS_LOSING)
    fprintf(stderr, "dropped packets detected\n");
    header->tp_status = TP_STATUS_KERNEL;

  // return encapsulated packet
  return ((char *) header) + header->tp_mac;
}

int strange_receive(char * receiveBuffer, int msgBlockSize, struct sockaddr_in6 *targetIP, struct in6_addr *ipv6Pointer){
    while (1) {
        struct ethhdr *ethhdr = rcv_mmap();
        printNBytes((char *)ethhdr, 200);
        struct ip6_hdr *iphdr = (struct ip6_hdr *)((char *)ethhdr + ETH_HDRLEN);
        struct udphdr *udphdr = (struct udphdr *)((char *)ethhdr + ETH_HDRLEN + IP6_HDRLEN);
        char* payload = ((char *)ethhdr + ETH_HDRLEN + IP6_HDRLEN + UDP_HDRLEN);
        printf("Coming from port src %d dest %d myport %d\n", ntohs(udphdr->source), ntohs(udphdr->dest), ntohs(packetinfo->udphdr.source));
        char s[INET6_ADDRSTRLEN];
        char s1[INET6_ADDRSTRLEN];
        inet_ntop(AF_INET6, &iphdr->ip6_dst, s, sizeof s);
        inet_ntop(AF_INET6, &iphdr->ip6_src, s1, sizeof s1);

        printf("Got message from src %s dst %s\n", s1, s);
    /*                if ( !memcmp(&iphdr->ip6_src, &iphdr->ip6_dst, 16)) {
            printf("SOURCE AND DESTINATION IP ARE THE SAME!!\n");
            sleep(15);
        }*/

        if (!memcmp(&udphdr->dest, &packetinfo->udphdr.source, sizeof(uint16_t)) && memcmp(&iphdr->ip6_src, &iphdr->ip6_dst, 16)) {
            memcpy(receiveBuffer,payload, msgBlockSize);
            if (ipv6Pointer != NULL)
                memcpy(ipv6Pointer->s6_addr,&iphdr->ip6_dst,IPV6_SIZE);
            memcpy(targetIP->sin6_addr.s6_addr,&iphdr->ip6_src,IPV6_SIZE);
            targetIP->sin6_port = udphdr->source;
    /*                    char s[INET6_ADDRSTRLEN];
            inet_ntop(AF_INET6, &targetIP->sin6_addr, s, sizeof s);
            printf("Got message from %s:%d\n", s, ntohs(targetIP->sin6_port))*/;
            udphdr->dest = 0;
            break;
        }
    }
    process_rx_release(ring);
    return msgBlockSize;

}

struct sockaddr_in6 *init_rcv_socket_test() {

    struct sockaddr_in6 *temp = malloc(sizeof(struct sockaddr_in6));
    packetinfo = getPacketInfo();
    init_packetsock();
    bind(sd_rcv, (struct sockaddr *) &packetinfo->device, sizeof (packetinfo->device) );
    return temp;
}