%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\dinv design}
\label{sec:instrumentation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Applying \dinv to a system consists of four steps
(~\ref{fig:dinv-flow}): (1) source code instrumentation, (2) system
execution to generate runtime logs, (3) mining of distributed program
states from the logs, and (4) determining likely distributed state
invariants from distributed states\iv{dist program points??}. This
section details each of these steps.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[t]
\centering
    \includegraphics[width=.9\textwidth]{fig/dinv-flow.pdf}
    \caption{Overview of our approach.}
    \label{fig:dinv-flow}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{System instrumentation}
\label{sec:instrumentation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\dinv instruments a node's source code to produce a runtime log
containing vector timestamped node state (each process maintains its
own vector clock).
%%   when the
%% instrumented program is executed. A log requires vector timestamps to
%% establish a partial ordering, and the values of variables defining the
%% nodes state.
Maintaining vector clocks (see Appendix~\ref{sec:formal-vector-clocks}
for the algorithm) and logging of variables require separate forms of
instrumentation.  We developed automated techniques for both.

Dinv introduces vector clocks automatically by mutating the AST and by
exploiting the conventions followed by Go's networking \textit{net}
library. This library implements TCP, IP, UDP, RPC, and IPC protocols;
all of these except for RPC share function signature conventions which
Dinv wraps:
%% Dinv injects a custom wrapper function, and pass the original
%% function, and its arguments into the wrapper.  Within a wrapper
%% function,
vector clocks are appended or stripped from network payloads, and the
original function is executed on the instrumented arguments. For
example, a network write like \texttt{conn.Write(buffer)} becomes
\texttt{dinv.Write(conn.Write,buffer)}.  For Go's RPC, which required
a different approach, we built a custom codec. In sum this enables the
automatic addition of vector clocks to any Go program that uses the
\textit{net} library.

%%  in the background. Initializing an RPC
%% connection requires calls to the standard RPC library.
%
%% The same function capturing technique which injects vector clocks is used on
%% such calls to automatically inject the vector clock codec.
%
\subsection{Logging state}

Logging state is the second half of instrumentation. At each event
instance a node has a distinct state and each instruction that it
executes potentially modifies this state.
%% Capturing state is an essential component of recording a log. 
%% , as such a complete log would contain the values of all variables
%% recorded after the execution of each instruction.
In practice recording at this granularity would produce an
unmanageably large log. An alternative that Dinv uses is to log a
subset of variables and at select times.

Figure~\ref{fig:data-flow} lists the source code for a simplified Serf
node. The source contains two logging points, in the form of
\emph{Dump} annotation (orange) and a paramatrized \emph{Dump}
statement (magenta), described in Section~\ref{sec:logging-functions}.
The first logs state when a \emph{Ping} message is received, the other
logs state before checking for timeouts.  Both statements log
variables within the received message and the events stored on the
Serf node. The figure highlights in red the variables affected by a
network read. The red highlighed variables are detected automatically
through static analysis by \dinvs instrumentation described in
Section~\ref{sec:logging-variables}, and will be logged by the
\emph{//@dump} annotation post instrumentation.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[h]
    \includegraphics[width=0.50\textwidth]{fig/data-flow-2}
    
    \caption{Example demonstrating data-flow analysis Highlighted in
        red are networking variables contained in the forward slice
        from $msg := conn.Read()$. A dump annotation is highlighted in
        orange. Highlighted in magenta is logging code translated from
        an annotation containing networking variables.}

  \label{fig:data-flow}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Automatically logging variables}
%%%%%%%%%%%%%%%%%%%%%
\label{sec:logging-variables}
We propose that the relevant state of a distributed system is composed
of variables which interact with the network. Dinv determines these
variables statically using program slicing~\cite{Ottenstein:1984}. It
then translates any logging annotations in the code to statements that
log the values of these variables that are in scope at the annotation
point.

Data read from a network transitively affects variables which interact
with it, while variables which affect the contents of network writes
have a transitive influence on the behaviour of any node which
receives the message. These \emph{network interacting variables}
influence the state of other nodes, and properties that range over
these variables capture information about the consistency of
distributed state.
%% Some variables are resigned solely to local computation, and do not
%% interact with the network.  Testing invariants of such variables on
%% separate nodes would yield arbitrary results. To derive meaningful
%% distributed invariants we partition these sets of variables and
%% only log \emph{network interacting variables}, which can be
%% detected statically using program slicing~\cite{Ottenstein:1984}.

A program slice, is a subset of statements in a program, which either
affect or are affected by some root statement. Forward slicing
computes the set of statements affected by the root. Backwards slicing
computes the set of statements which affect the root. \dinv extends
Ottenstein's algorithm~\cite{Ottenstein:1984} for building a program
dependence graph (PDG) 
%% . PDG are limited to the scope of a function, we extended
%% Ottensteins algorithm using
with interprocedural analysis and builds a system dependence
graph~\cite{Walkinshaw03thejava}. %% and use it to compute program
%% slices. 
The roots of the slices in Dinv are network function calls. Dinv
generates the set of variables to log by computing backwards slices
from network writes and forward slices from network reads. The general
algorithm for source code instrumentation is descibed in
Algorithm~\ref{alg:instrument}.
%

\subsubsection{Log injection techniques} 
%
Logging \emph{network interacting variables} after each executed
instruction would still produce an unmanageably large log. %% Dinv
%% resolves this by logging at just select program points.
%% Determining the points on which a nodes state holds interesting
%% invariant properties, requires semantic analysis beyond the scope
%% of this paper.
Dinv includes two methods for identifying logging locations: a
general-purpose automated approach and an approach based on
developed-supplied annotations (Table~\ref{table:inst-strat}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\small
%    \begin{tabular}{| p{2.0cm} | p{1.0cm} | p{1.0cm} |}
\begin{tabular}{ l  l  l }
  \hline
  Instrumentation strategy & Location & Variables \\ 
  \hline
  Entrance and exit of functions  &   Auto   & Auto \\
  User placed annotations   & Manual  & Auto \\ 
  Paramatrized logging functions & Manual & Manual \\ 
  \hline
\end{tabular}
\caption{Instrumentation strategies and the control (automatic/manual)
  offered by each strategy for selecting state logging location and
  set of logged variables.}
\label{table:inst-strat}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Automated dump statement injection follows a general heuristic. The
source code of the program is scanned, and annotations are injected at
the entry and exit point of each function in the program.
%
Semi-automated logging statements require the addition of annotations
by either a developer, or by automated injection. Once a program has
been annotated, \dinv analyzes the source code using program slicing,
and replaces the annotations with logging code.
Algorithm~\ref{alg:instrument} details this process at a high level.
%
Manual logging statements are specified explicitly by developers. They
specify a list of variables as arguments, and log them. This offers
fine-grained control over the instrumentation. In cases where many
variables are in scope and interact with the network the majority of
detected invariants are irrelevant to a desired system property and
obfuscate \dinv's output. We preferable when verifying invariants on
small sets of variables.
%

\subsubsection{Logging functions}
\label{sec:logging-functions}
One factor which complicates logging variables is their scope.
Conventionally variables are logged at a specific point in a programs
execution, this has the advantage of capturing values at a specific
moment in time, but also isolates them from being analyzed with
variables which are present in another scope. To address situations
where the variables should be logged at a specific point, and
situations where sets of variables in different scopes should be
logged together, \dinv has two distinct logging functions.

\textit{Dump} writes the values of variables directly to a log when it
is executed. Each unique dump statement is later merged as an
independent entity, the result is invariants which reflect system
invariants at arbitrary points. %Writes variables immediately to a log.

\textit{Track} writes variables to a hashmap and delays writing these
to a log until the local vector time is incremented. By deferring and
aggregating state a more complete view of a node's state can be
analyzed together, at the cost of precision.

%% The annotations for both functions are \textit{//@dump} and
%% \textit{//@track} respectively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}[t]
    \KwData{Source code with dump statements $S$}
\KwResult{Instrumented Source Code $I$}

    $I$ = $S$ \\
    $dumpNode$ = CollectDumpAnnotationASTNodes($S$) \\
    \For{$dump \in dumpNodes$} {
        $variables$ = ComputeAffected($dump.line$,$S$)\\
        $loggingCode$ = NewLoggingCode($variables$, $dump.line$, $S$)\\
        $I$ += $loggingCode$\\
    }
    \Return{$Delta$}
    \caption{Algorithm converting commented logging annotation to logging code.}
    \label{alg:instrument}
\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% In this section we outlined the two step procedure by which  \dinv
%% instruments a programs source code to produce a log. \dinv
%% automatically wraps network communication in order to maintain a
%% vector clock with the other nodes in the system.  Secondly, variable
%% logging statements are added using any configuration of the automated,
%% semi-automated, or manual dumping methods. In
%% Section~\ref{sec:log-analysis} we describe how the log is processed.
