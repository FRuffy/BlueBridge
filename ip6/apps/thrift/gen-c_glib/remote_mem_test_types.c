/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "remote_mem_test_types.h"
#include <thrift/c_glib/thrift.h>

/* constants */

/* reads a remote_mem_test_ping_args object */
static gint32
remote_mem_test_ping_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RemoteMemTestPingArgs * this_object = REMOTE_MEM_TEST_PING_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
remote_mem_test_ping_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RemoteMemTestPingArgs * this_object = REMOTE_MEM_TEST_PING_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RemoteMemTestPingArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
remote_mem_test_ping_args_instance_init (RemoteMemTestPingArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
remote_mem_test_ping_args_finalize (GObject *object)
{
  RemoteMemTestPingArgs *tobject = REMOTE_MEM_TEST_PING_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
remote_mem_test_ping_args_class_init (RemoteMemTestPingArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = remote_mem_test_ping_args_read;
  struct_class->write = remote_mem_test_ping_args_write;

  gobject_class->finalize = remote_mem_test_ping_args_finalize;
}

GType
remote_mem_test_ping_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RemoteMemTestPingArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) remote_mem_test_ping_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RemoteMemTestPingArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) remote_mem_test_ping_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RemoteMemTestPingArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a remote_mem_test_ping_result object */
static gint32
remote_mem_test_ping_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RemoteMemTestPingResult * this_object = REMOTE_MEM_TEST_PING_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
remote_mem_test_ping_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RemoteMemTestPingResult * this_object = REMOTE_MEM_TEST_PING_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RemoteMemTestPingResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
remote_mem_test_ping_result_instance_init (RemoteMemTestPingResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
remote_mem_test_ping_result_finalize (GObject *object)
{
  RemoteMemTestPingResult *tobject = REMOTE_MEM_TEST_PING_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
remote_mem_test_ping_result_class_init (RemoteMemTestPingResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = remote_mem_test_ping_result_read;
  struct_class->write = remote_mem_test_ping_result_write;

  gobject_class->finalize = remote_mem_test_ping_result_finalize;
}

GType
remote_mem_test_ping_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RemoteMemTestPingResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) remote_mem_test_ping_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RemoteMemTestPingResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) remote_mem_test_ping_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RemoteMemTestPingResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _RemoteMemTestAllocateMemArgsProperties
{
  PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_ARGS_0,
  PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_ARGS_SIZE
};

/* reads a remote_mem_test_allocate_mem_args object */
static gint32
remote_mem_test_allocate_mem_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RemoteMemTestAllocateMemArgs * this_object = REMOTE_MEM_TEST_ALLOCATE_MEM_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
remote_mem_test_allocate_mem_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RemoteMemTestAllocateMemArgs * this_object = REMOTE_MEM_TEST_ALLOCATE_MEM_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RemoteMemTestAllocateMemArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "size", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->size, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
remote_mem_test_allocate_mem_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  RemoteMemTestAllocateMemArgs *self = REMOTE_MEM_TEST_ALLOCATE_MEM_ARGS (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_ARGS_SIZE:
      self->size = g_value_get_int (value);
      self->__isset_size = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
remote_mem_test_allocate_mem_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  RemoteMemTestAllocateMemArgs *self = REMOTE_MEM_TEST_ALLOCATE_MEM_ARGS (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_ARGS_SIZE:
      g_value_set_int (value, self->size);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
remote_mem_test_allocate_mem_args_instance_init (RemoteMemTestAllocateMemArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->size = 0;
  object->__isset_size = FALSE;
}

static void 
remote_mem_test_allocate_mem_args_finalize (GObject *object)
{
  RemoteMemTestAllocateMemArgs *tobject = REMOTE_MEM_TEST_ALLOCATE_MEM_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
remote_mem_test_allocate_mem_args_class_init (RemoteMemTestAllocateMemArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = remote_mem_test_allocate_mem_args_read;
  struct_class->write = remote_mem_test_allocate_mem_args_write;

  gobject_class->finalize = remote_mem_test_allocate_mem_args_finalize;
  gobject_class->get_property = remote_mem_test_allocate_mem_args_get_property;
  gobject_class->set_property = remote_mem_test_allocate_mem_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_ARGS_SIZE,
     g_param_spec_int ("size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
remote_mem_test_allocate_mem_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RemoteMemTestAllocateMemArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) remote_mem_test_allocate_mem_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RemoteMemTestAllocateMemArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) remote_mem_test_allocate_mem_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RemoteMemTestAllocateMemArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _RemoteMemTestAllocateMemResultProperties
{
  PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT_0,
  PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT_SUCCESS,
  PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT_OUCH
};

/* reads a remote_mem_test_allocate_mem_result object */
static gint32
remote_mem_test_allocate_mem_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RemoteMemTestAllocateMemResult * this_object = REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (TYPE_CALL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
remote_mem_test_allocate_mem_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RemoteMemTestAllocateMemResult * this_object = REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RemoteMemTestAllocateMemResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->success)->data, ((GByteArray *) this_object->success)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
remote_mem_test_allocate_mem_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  RemoteMemTestAllocateMemResult *self = REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
remote_mem_test_allocate_mem_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  RemoteMemTestAllocateMemResult *self = REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
remote_mem_test_allocate_mem_result_instance_init (RemoteMemTestAllocateMemResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
remote_mem_test_allocate_mem_result_finalize (GObject *object)
{
  RemoteMemTestAllocateMemResult *tobject = REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
remote_mem_test_allocate_mem_result_class_init (RemoteMemTestAllocateMemResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = remote_mem_test_allocate_mem_result_read;
  struct_class->write = remote_mem_test_allocate_mem_result_write;

  gobject_class->finalize = remote_mem_test_allocate_mem_result_finalize;
  gobject_class->get_property = remote_mem_test_allocate_mem_result_get_property;
  gobject_class->set_property = remote_mem_test_allocate_mem_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REMOTE_MEM_TEST_ALLOCATE_MEM_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         TYPE_CALL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
remote_mem_test_allocate_mem_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RemoteMemTestAllocateMemResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) remote_mem_test_allocate_mem_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RemoteMemTestAllocateMemResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) remote_mem_test_allocate_mem_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RemoteMemTestAllocateMemResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _RemoteMemTestReadMemArgsProperties
{
  PROP_REMOTE_MEM_TEST_READ_MEM_ARGS_0,
  PROP_REMOTE_MEM_TEST_READ_MEM_ARGS_POINTER
};

/* reads a remote_mem_test_read_mem_args object */
static gint32
remote_mem_test_read_mem_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RemoteMemTestReadMemArgs * this_object = REMOTE_MEM_TEST_READ_MEM_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->pointer != NULL)
          {
            g_free(this_object->pointer);
            this_object->pointer = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pointer = g_byte_array_new();
          g_byte_array_append (this_object->pointer, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pointer = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
remote_mem_test_read_mem_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RemoteMemTestReadMemArgs * this_object = REMOTE_MEM_TEST_READ_MEM_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RemoteMemTestReadMemArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pointer", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->pointer)->data, ((GByteArray *) this_object->pointer)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
remote_mem_test_read_mem_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  RemoteMemTestReadMemArgs *self = REMOTE_MEM_TEST_READ_MEM_ARGS (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_READ_MEM_ARGS_POINTER:
      if (self->pointer != NULL)
        g_byte_array_unref (self->pointer);
      self->pointer = g_value_dup_boxed (value);
      self->__isset_pointer = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
remote_mem_test_read_mem_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  RemoteMemTestReadMemArgs *self = REMOTE_MEM_TEST_READ_MEM_ARGS (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_READ_MEM_ARGS_POINTER:
      g_value_set_boxed (value, self->pointer);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
remote_mem_test_read_mem_args_instance_init (RemoteMemTestReadMemArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pointer = NULL;
  object->__isset_pointer = FALSE;
}

static void 
remote_mem_test_read_mem_args_finalize (GObject *object)
{
  RemoteMemTestReadMemArgs *tobject = REMOTE_MEM_TEST_READ_MEM_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pointer != NULL)
  {
    thrift_string_free(tobject->pointer);
    tobject->pointer = NULL;
  }
}

static void
remote_mem_test_read_mem_args_class_init (RemoteMemTestReadMemArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = remote_mem_test_read_mem_args_read;
  struct_class->write = remote_mem_test_read_mem_args_write;

  gobject_class->finalize = remote_mem_test_read_mem_args_finalize;
  gobject_class->get_property = remote_mem_test_read_mem_args_get_property;
  gobject_class->set_property = remote_mem_test_read_mem_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REMOTE_MEM_TEST_READ_MEM_ARGS_POINTER,
     g_param_spec_boxed ("pointer",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
remote_mem_test_read_mem_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RemoteMemTestReadMemArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) remote_mem_test_read_mem_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RemoteMemTestReadMemArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) remote_mem_test_read_mem_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RemoteMemTestReadMemArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _RemoteMemTestReadMemResultProperties
{
  PROP_REMOTE_MEM_TEST_READ_MEM_RESULT_0,
  PROP_REMOTE_MEM_TEST_READ_MEM_RESULT_OUCH
};

/* reads a remote_mem_test_read_mem_result object */
static gint32
remote_mem_test_read_mem_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RemoteMemTestReadMemResult * this_object = REMOTE_MEM_TEST_READ_MEM_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (TYPE_CALL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
remote_mem_test_read_mem_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RemoteMemTestReadMemResult * this_object = REMOTE_MEM_TEST_READ_MEM_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RemoteMemTestReadMemResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
remote_mem_test_read_mem_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  RemoteMemTestReadMemResult *self = REMOTE_MEM_TEST_READ_MEM_RESULT (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_READ_MEM_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
remote_mem_test_read_mem_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  RemoteMemTestReadMemResult *self = REMOTE_MEM_TEST_READ_MEM_RESULT (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_READ_MEM_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
remote_mem_test_read_mem_result_instance_init (RemoteMemTestReadMemResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
remote_mem_test_read_mem_result_finalize (GObject *object)
{
  RemoteMemTestReadMemResult *tobject = REMOTE_MEM_TEST_READ_MEM_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
remote_mem_test_read_mem_result_class_init (RemoteMemTestReadMemResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = remote_mem_test_read_mem_result_read;
  struct_class->write = remote_mem_test_read_mem_result_write;

  gobject_class->finalize = remote_mem_test_read_mem_result_finalize;
  gobject_class->get_property = remote_mem_test_read_mem_result_get_property;
  gobject_class->set_property = remote_mem_test_read_mem_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REMOTE_MEM_TEST_READ_MEM_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         TYPE_CALL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
remote_mem_test_read_mem_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RemoteMemTestReadMemResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) remote_mem_test_read_mem_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RemoteMemTestReadMemResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) remote_mem_test_read_mem_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RemoteMemTestReadMemResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _RemoteMemTestWriteMemArgsProperties
{
  PROP_REMOTE_MEM_TEST_WRITE_MEM_ARGS_0,
  PROP_REMOTE_MEM_TEST_WRITE_MEM_ARGS_POINTER,
  PROP_REMOTE_MEM_TEST_WRITE_MEM_ARGS_MESSAGE
};

/* reads a remote_mem_test_write_mem_args object */
static gint32
remote_mem_test_write_mem_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RemoteMemTestWriteMemArgs * this_object = REMOTE_MEM_TEST_WRITE_MEM_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->pointer != NULL)
          {
            g_free(this_object->pointer);
            this_object->pointer = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pointer = g_byte_array_new();
          g_byte_array_append (this_object->pointer, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pointer = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
remote_mem_test_write_mem_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RemoteMemTestWriteMemArgs * this_object = REMOTE_MEM_TEST_WRITE_MEM_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RemoteMemTestWriteMemArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pointer", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->pointer)->data, ((GByteArray *) this_object->pointer)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
remote_mem_test_write_mem_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  RemoteMemTestWriteMemArgs *self = REMOTE_MEM_TEST_WRITE_MEM_ARGS (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_WRITE_MEM_ARGS_POINTER:
      if (self->pointer != NULL)
        g_byte_array_unref (self->pointer);
      self->pointer = g_value_dup_boxed (value);
      self->__isset_pointer = TRUE;
      break;

    case PROP_REMOTE_MEM_TEST_WRITE_MEM_ARGS_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
remote_mem_test_write_mem_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  RemoteMemTestWriteMemArgs *self = REMOTE_MEM_TEST_WRITE_MEM_ARGS (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_WRITE_MEM_ARGS_POINTER:
      g_value_set_boxed (value, self->pointer);
      break;

    case PROP_REMOTE_MEM_TEST_WRITE_MEM_ARGS_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
remote_mem_test_write_mem_args_instance_init (RemoteMemTestWriteMemArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pointer = NULL;
  object->__isset_pointer = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
remote_mem_test_write_mem_args_finalize (GObject *object)
{
  RemoteMemTestWriteMemArgs *tobject = REMOTE_MEM_TEST_WRITE_MEM_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pointer != NULL)
  {
    thrift_string_free(tobject->pointer);
    tobject->pointer = NULL;
  }
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
remote_mem_test_write_mem_args_class_init (RemoteMemTestWriteMemArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = remote_mem_test_write_mem_args_read;
  struct_class->write = remote_mem_test_write_mem_args_write;

  gobject_class->finalize = remote_mem_test_write_mem_args_finalize;
  gobject_class->get_property = remote_mem_test_write_mem_args_get_property;
  gobject_class->set_property = remote_mem_test_write_mem_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REMOTE_MEM_TEST_WRITE_MEM_ARGS_POINTER,
     g_param_spec_boxed ("pointer",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REMOTE_MEM_TEST_WRITE_MEM_ARGS_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
remote_mem_test_write_mem_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RemoteMemTestWriteMemArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) remote_mem_test_write_mem_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RemoteMemTestWriteMemArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) remote_mem_test_write_mem_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RemoteMemTestWriteMemArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _RemoteMemTestWriteMemResultProperties
{
  PROP_REMOTE_MEM_TEST_WRITE_MEM_RESULT_0,
  PROP_REMOTE_MEM_TEST_WRITE_MEM_RESULT_OUCH
};

/* reads a remote_mem_test_write_mem_result object */
static gint32
remote_mem_test_write_mem_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RemoteMemTestWriteMemResult * this_object = REMOTE_MEM_TEST_WRITE_MEM_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (TYPE_CALL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
remote_mem_test_write_mem_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RemoteMemTestWriteMemResult * this_object = REMOTE_MEM_TEST_WRITE_MEM_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RemoteMemTestWriteMemResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
remote_mem_test_write_mem_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  RemoteMemTestWriteMemResult *self = REMOTE_MEM_TEST_WRITE_MEM_RESULT (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_WRITE_MEM_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
remote_mem_test_write_mem_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  RemoteMemTestWriteMemResult *self = REMOTE_MEM_TEST_WRITE_MEM_RESULT (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_WRITE_MEM_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
remote_mem_test_write_mem_result_instance_init (RemoteMemTestWriteMemResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
remote_mem_test_write_mem_result_finalize (GObject *object)
{
  RemoteMemTestWriteMemResult *tobject = REMOTE_MEM_TEST_WRITE_MEM_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
remote_mem_test_write_mem_result_class_init (RemoteMemTestWriteMemResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = remote_mem_test_write_mem_result_read;
  struct_class->write = remote_mem_test_write_mem_result_write;

  gobject_class->finalize = remote_mem_test_write_mem_result_finalize;
  gobject_class->get_property = remote_mem_test_write_mem_result_get_property;
  gobject_class->set_property = remote_mem_test_write_mem_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REMOTE_MEM_TEST_WRITE_MEM_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         TYPE_CALL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
remote_mem_test_write_mem_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RemoteMemTestWriteMemResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) remote_mem_test_write_mem_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RemoteMemTestWriteMemResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) remote_mem_test_write_mem_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RemoteMemTestWriteMemResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _RemoteMemTestFreeMemArgsProperties
{
  PROP_REMOTE_MEM_TEST_FREE_MEM_ARGS_0,
  PROP_REMOTE_MEM_TEST_FREE_MEM_ARGS_POINTER
};

/* reads a remote_mem_test_free_mem_args object */
static gint32
remote_mem_test_free_mem_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RemoteMemTestFreeMemArgs * this_object = REMOTE_MEM_TEST_FREE_MEM_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->pointer != NULL)
          {
            g_free(this_object->pointer);
            this_object->pointer = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pointer = g_byte_array_new();
          g_byte_array_append (this_object->pointer, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pointer = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
remote_mem_test_free_mem_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RemoteMemTestFreeMemArgs * this_object = REMOTE_MEM_TEST_FREE_MEM_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RemoteMemTestFreeMemArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pointer", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->pointer)->data, ((GByteArray *) this_object->pointer)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
remote_mem_test_free_mem_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  RemoteMemTestFreeMemArgs *self = REMOTE_MEM_TEST_FREE_MEM_ARGS (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_FREE_MEM_ARGS_POINTER:
      if (self->pointer != NULL)
        g_byte_array_unref (self->pointer);
      self->pointer = g_value_dup_boxed (value);
      self->__isset_pointer = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
remote_mem_test_free_mem_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  RemoteMemTestFreeMemArgs *self = REMOTE_MEM_TEST_FREE_MEM_ARGS (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_FREE_MEM_ARGS_POINTER:
      g_value_set_boxed (value, self->pointer);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
remote_mem_test_free_mem_args_instance_init (RemoteMemTestFreeMemArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pointer = NULL;
  object->__isset_pointer = FALSE;
}

static void 
remote_mem_test_free_mem_args_finalize (GObject *object)
{
  RemoteMemTestFreeMemArgs *tobject = REMOTE_MEM_TEST_FREE_MEM_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pointer != NULL)
  {
    thrift_string_free(tobject->pointer);
    tobject->pointer = NULL;
  }
}

static void
remote_mem_test_free_mem_args_class_init (RemoteMemTestFreeMemArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = remote_mem_test_free_mem_args_read;
  struct_class->write = remote_mem_test_free_mem_args_write;

  gobject_class->finalize = remote_mem_test_free_mem_args_finalize;
  gobject_class->get_property = remote_mem_test_free_mem_args_get_property;
  gobject_class->set_property = remote_mem_test_free_mem_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REMOTE_MEM_TEST_FREE_MEM_ARGS_POINTER,
     g_param_spec_boxed ("pointer",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
remote_mem_test_free_mem_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RemoteMemTestFreeMemArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) remote_mem_test_free_mem_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RemoteMemTestFreeMemArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) remote_mem_test_free_mem_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RemoteMemTestFreeMemArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _RemoteMemTestFreeMemResultProperties
{
  PROP_REMOTE_MEM_TEST_FREE_MEM_RESULT_0,
  PROP_REMOTE_MEM_TEST_FREE_MEM_RESULT_OUCH
};

/* reads a remote_mem_test_free_mem_result object */
static gint32
remote_mem_test_free_mem_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RemoteMemTestFreeMemResult * this_object = REMOTE_MEM_TEST_FREE_MEM_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (TYPE_CALL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
remote_mem_test_free_mem_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RemoteMemTestFreeMemResult * this_object = REMOTE_MEM_TEST_FREE_MEM_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RemoteMemTestFreeMemResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
remote_mem_test_free_mem_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  RemoteMemTestFreeMemResult *self = REMOTE_MEM_TEST_FREE_MEM_RESULT (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_FREE_MEM_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
remote_mem_test_free_mem_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  RemoteMemTestFreeMemResult *self = REMOTE_MEM_TEST_FREE_MEM_RESULT (object);

  switch (property_id)
  {
    case PROP_REMOTE_MEM_TEST_FREE_MEM_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
remote_mem_test_free_mem_result_instance_init (RemoteMemTestFreeMemResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
remote_mem_test_free_mem_result_finalize (GObject *object)
{
  RemoteMemTestFreeMemResult *tobject = REMOTE_MEM_TEST_FREE_MEM_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
remote_mem_test_free_mem_result_class_init (RemoteMemTestFreeMemResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = remote_mem_test_free_mem_result_read;
  struct_class->write = remote_mem_test_free_mem_result_write;

  gobject_class->finalize = remote_mem_test_free_mem_result_finalize;
  gobject_class->get_property = remote_mem_test_free_mem_result_get_property;
  gobject_class->set_property = remote_mem_test_free_mem_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REMOTE_MEM_TEST_FREE_MEM_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         TYPE_CALL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
remote_mem_test_free_mem_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RemoteMemTestFreeMemResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) remote_mem_test_free_mem_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RemoteMemTestFreeMemResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) remote_mem_test_free_mem_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RemoteMemTestFreeMemResultType",
                                   &type_info, 0);
  }

  return type;
}

