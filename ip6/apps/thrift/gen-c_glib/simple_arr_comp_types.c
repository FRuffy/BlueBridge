/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "simple_arr_comp_types.h"
#include <thrift/c_glib/thrift.h>

enum _tupleProperties
{
  PROP_TUPLE_0,
  PROP_TUPLE_N,
  PROP_TUPLE_M
};

/* reads a tuple object */
static gint32
tuple_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  tuple * this_object = TUPLE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->n, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_n = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->m, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_m = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tuple_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  tuple * this_object = TUPLE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "tuple", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "n", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->n, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "m", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->m, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tuple_set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  tuple *self = TUPLE (object);

  switch (property_id)
  {
    case PROP_TUPLE_N:
      self->n = g_value_get_int (value);
      self->__isset_n = TRUE;
      break;

    case PROP_TUPLE_M:
      self->m = g_value_get_int (value);
      self->__isset_m = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tuple_get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  tuple *self = TUPLE (object);

  switch (property_id)
  {
    case PROP_TUPLE_N:
      g_value_set_int (value, self->n);
      break;

    case PROP_TUPLE_M:
      g_value_set_int (value, self->m);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tuple_instance_init (tuple * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->n = 0;
  object->__isset_n = FALSE;
  object->m = 0;
  object->__isset_m = FALSE;
}

static void 
tuple_finalize (GObject *object)
{
  tuple *tobject = TUPLE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
tuple_class_init (tupleClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tuple_read;
  struct_class->write = tuple_write;

  gobject_class->finalize = tuple_finalize;
  gobject_class->get_property = tuple_get_property;
  gobject_class->set_property = tuple_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TUPLE_N,
     g_param_spec_int ("n",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TUPLE_M,
     g_param_spec_int ("m",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
tuple_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (tupleClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tuple_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (tuple),
      0, /* n_preallocs */
      (GInstanceInitFunc) tuple_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "tupleType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _SimpleArrCompIncrementArrayArgsProperties
{
  PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_0,
  PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_ARR,
  PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_VALUE,
  PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_LENGTH
};

/* reads a simple_arr_comp_increment_array_args object */
static gint32
simple_arr_comp_increment_array_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompIncrementArrayArgs * this_object = SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->arr != NULL)
          {
            g_free(this_object->arr);
            this_object->arr = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->arr = g_byte_array_new();
          g_byte_array_append (this_object->arr, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_arr = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_increment_array_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompIncrementArrayArgs * this_object = SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompIncrementArrayArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arr", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->arr)->data, ((GByteArray *) this_object->arr)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->value, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "length", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->length, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_increment_array_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  SimpleArrCompIncrementArrayArgs *self = SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_ARR:
      if (self->arr != NULL)
        g_byte_array_unref (self->arr);
      self->arr = g_value_dup_boxed (value);
      self->__isset_arr = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_VALUE:
      self->value = g_value_get_int (value);
      self->__isset_value = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_LENGTH:
      self->length = g_value_get_int (value);
      self->__isset_length = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_increment_array_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  SimpleArrCompIncrementArrayArgs *self = SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_ARR:
      g_value_set_boxed (value, self->arr);
      break;

    case PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_VALUE:
      g_value_set_int (value, self->value);
      break;

    case PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_LENGTH:
      g_value_set_int (value, self->length);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_increment_array_args_instance_init (SimpleArrCompIncrementArrayArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->arr = NULL;
  object->__isset_arr = FALSE;
  object->value = 0;
  object->__isset_value = FALSE;
  object->length = 0;
  object->__isset_length = FALSE;
}

static void 
simple_arr_comp_increment_array_args_finalize (GObject *object)
{
  SimpleArrCompIncrementArrayArgs *tobject = SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->arr != NULL)
  {
    thrift_string_free(tobject->arr);
    tobject->arr = NULL;
  }
}

static void
simple_arr_comp_increment_array_args_class_init (SimpleArrCompIncrementArrayArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_increment_array_args_read;
  struct_class->write = simple_arr_comp_increment_array_args_write;

  gobject_class->finalize = simple_arr_comp_increment_array_args_finalize;
  gobject_class->get_property = simple_arr_comp_increment_array_args_get_property;
  gobject_class->set_property = simple_arr_comp_increment_array_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_ARR,
     g_param_spec_boxed ("arr",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_VALUE,
     g_param_spec_int ("value",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_ARGS_LENGTH,
     g_param_spec_int ("length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
simple_arr_comp_increment_array_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompIncrementArrayArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_increment_array_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompIncrementArrayArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_increment_array_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompIncrementArrayArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompIncrementArrayResultProperties
{
  PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT_0,
  PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT_SUCCESS,
  PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT_OUCH
};

/* reads a simple_arr_comp_increment_array_result object */
static gint32
simple_arr_comp_increment_array_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompIncrementArrayResult * this_object = SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (TYPE_CALL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_increment_array_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompIncrementArrayResult * this_object = SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompIncrementArrayResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->success)->data, ((GByteArray *) this_object->success)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_increment_array_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  SimpleArrCompIncrementArrayResult *self = SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_increment_array_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  SimpleArrCompIncrementArrayResult *self = SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_increment_array_result_instance_init (SimpleArrCompIncrementArrayResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
simple_arr_comp_increment_array_result_finalize (GObject *object)
{
  SimpleArrCompIncrementArrayResult *tobject = SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
simple_arr_comp_increment_array_result_class_init (SimpleArrCompIncrementArrayResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_increment_array_result_read;
  struct_class->write = simple_arr_comp_increment_array_result_write;

  gobject_class->finalize = simple_arr_comp_increment_array_result_finalize;
  gobject_class->get_property = simple_arr_comp_increment_array_result_get_property;
  gobject_class->set_property = simple_arr_comp_increment_array_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_INCREMENT_ARRAY_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         TYPE_CALL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
simple_arr_comp_increment_array_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompIncrementArrayResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_increment_array_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompIncrementArrayResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_increment_array_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompIncrementArrayResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompAddArraysArgsProperties
{
  PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_0,
  PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_ARRAY1,
  PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_ARRAY2,
  PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_LENGTH
};

/* reads a simple_arr_comp_add_arrays_args object */
static gint32
simple_arr_comp_add_arrays_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompAddArraysArgs * this_object = SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->array1 != NULL)
          {
            g_free(this_object->array1);
            this_object->array1 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->array1 = g_byte_array_new();
          g_byte_array_append (this_object->array1, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_array1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->array2 != NULL)
          {
            g_free(this_object->array2);
            this_object->array2 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->array2 = g_byte_array_new();
          g_byte_array_append (this_object->array2, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_array2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_add_arrays_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompAddArraysArgs * this_object = SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompAddArraysArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "array1", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->array1)->data, ((GByteArray *) this_object->array1)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "array2", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->array2)->data, ((GByteArray *) this_object->array2)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "length", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->length, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_add_arrays_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  SimpleArrCompAddArraysArgs *self = SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_ARRAY1:
      if (self->array1 != NULL)
        g_byte_array_unref (self->array1);
      self->array1 = g_value_dup_boxed (value);
      self->__isset_array1 = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_ARRAY2:
      if (self->array2 != NULL)
        g_byte_array_unref (self->array2);
      self->array2 = g_value_dup_boxed (value);
      self->__isset_array2 = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_LENGTH:
      self->length = g_value_get_int (value);
      self->__isset_length = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_add_arrays_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  SimpleArrCompAddArraysArgs *self = SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_ARRAY1:
      g_value_set_boxed (value, self->array1);
      break;

    case PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_ARRAY2:
      g_value_set_boxed (value, self->array2);
      break;

    case PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_LENGTH:
      g_value_set_int (value, self->length);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_add_arrays_args_instance_init (SimpleArrCompAddArraysArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->array1 = NULL;
  object->__isset_array1 = FALSE;
  object->array2 = NULL;
  object->__isset_array2 = FALSE;
  object->length = 0;
  object->__isset_length = FALSE;
}

static void 
simple_arr_comp_add_arrays_args_finalize (GObject *object)
{
  SimpleArrCompAddArraysArgs *tobject = SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->array1 != NULL)
  {
    thrift_string_free(tobject->array1);
    tobject->array1 = NULL;
  }
  if (tobject->array2 != NULL)
  {
    thrift_string_free(tobject->array2);
    tobject->array2 = NULL;
  }
}

static void
simple_arr_comp_add_arrays_args_class_init (SimpleArrCompAddArraysArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_add_arrays_args_read;
  struct_class->write = simple_arr_comp_add_arrays_args_write;

  gobject_class->finalize = simple_arr_comp_add_arrays_args_finalize;
  gobject_class->get_property = simple_arr_comp_add_arrays_args_get_property;
  gobject_class->set_property = simple_arr_comp_add_arrays_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_ARRAY1,
     g_param_spec_boxed ("array1",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_ARRAY2,
     g_param_spec_boxed ("array2",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_ARGS_LENGTH,
     g_param_spec_int ("length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
simple_arr_comp_add_arrays_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompAddArraysArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_add_arrays_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompAddArraysArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_add_arrays_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompAddArraysArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompAddArraysResultProperties
{
  PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT_0,
  PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT_SUCCESS,
  PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT_OUCH
};

/* reads a simple_arr_comp_add_arrays_result object */
static gint32
simple_arr_comp_add_arrays_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompAddArraysResult * this_object = SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (TYPE_CALL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_add_arrays_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompAddArraysResult * this_object = SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompAddArraysResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->success)->data, ((GByteArray *) this_object->success)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_add_arrays_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  SimpleArrCompAddArraysResult *self = SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_add_arrays_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  SimpleArrCompAddArraysResult *self = SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_add_arrays_result_instance_init (SimpleArrCompAddArraysResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
simple_arr_comp_add_arrays_result_finalize (GObject *object)
{
  SimpleArrCompAddArraysResult *tobject = SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
simple_arr_comp_add_arrays_result_class_init (SimpleArrCompAddArraysResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_add_arrays_result_read;
  struct_class->write = simple_arr_comp_add_arrays_result_write;

  gobject_class->finalize = simple_arr_comp_add_arrays_result_finalize;
  gobject_class->get_property = simple_arr_comp_add_arrays_result_get_property;
  gobject_class->set_property = simple_arr_comp_add_arrays_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_ADD_ARRAYS_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         TYPE_CALL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
simple_arr_comp_add_arrays_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompAddArraysResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_add_arrays_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompAddArraysResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_add_arrays_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompAddArraysResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompMatMultiplyArgsProperties
{
  PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_0,
  PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_ARRAY,
  PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_MATRIX,
  PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_LENGTH,
  PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_DIMENSION,
  PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_RESULT_PTR
};

/* reads a simple_arr_comp_mat_multiply_args object */
static gint32
simple_arr_comp_mat_multiply_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompMatMultiplyArgs * this_object = SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->array != NULL)
          {
            g_free(this_object->array);
            this_object->array = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->array = g_byte_array_new();
          g_byte_array_append (this_object->array, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_array = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->matrix != NULL)
          {
            g_free(this_object->matrix);
            this_object->matrix = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->matrix = g_byte_array_new();
          g_byte_array_append (this_object->matrix, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_matrix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->dimension), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_dimension = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->result_ptr != NULL)
          {
            g_free(this_object->result_ptr);
            this_object->result_ptr = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->result_ptr = g_byte_array_new();
          g_byte_array_append (this_object->result_ptr, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_result_ptr = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_mat_multiply_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompMatMultiplyArgs * this_object = SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompMatMultiplyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "array", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->array)->data, ((GByteArray *) this_object->array)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "matrix", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->matrix)->data, ((GByteArray *) this_object->matrix)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "length", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->length, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "dimension", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->dimension), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "result_ptr", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->result_ptr)->data, ((GByteArray *) this_object->result_ptr)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_mat_multiply_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  SimpleArrCompMatMultiplyArgs *self = SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_ARRAY:
      if (self->array != NULL)
        g_byte_array_unref (self->array);
      self->array = g_value_dup_boxed (value);
      self->__isset_array = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_MATRIX:
      if (self->matrix != NULL)
        g_byte_array_unref (self->matrix);
      self->matrix = g_value_dup_boxed (value);
      self->__isset_matrix = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_LENGTH:
      self->length = g_value_get_int (value);
      self->__isset_length = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_DIMENSION:
      if (self->dimension != NULL)
        g_object_unref (self->dimension);
      self->dimension = g_value_dup_object (value);
      self->__isset_dimension = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_RESULT_PTR:
      if (self->result_ptr != NULL)
        g_byte_array_unref (self->result_ptr);
      self->result_ptr = g_value_dup_boxed (value);
      self->__isset_result_ptr = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_mat_multiply_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  SimpleArrCompMatMultiplyArgs *self = SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_ARRAY:
      g_value_set_boxed (value, self->array);
      break;

    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_MATRIX:
      g_value_set_boxed (value, self->matrix);
      break;

    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_LENGTH:
      g_value_set_int (value, self->length);
      break;

    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_DIMENSION:
      g_value_set_object (value, self->dimension);
      break;

    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_RESULT_PTR:
      g_value_set_boxed (value, self->result_ptr);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_mat_multiply_args_instance_init (SimpleArrCompMatMultiplyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->array = NULL;
  object->__isset_array = FALSE;
  object->matrix = NULL;
  object->__isset_matrix = FALSE;
  object->length = 0;
  object->__isset_length = FALSE;
  object->dimension = g_object_new (TYPE_TUPLE, NULL);
  object->__isset_dimension = FALSE;
  object->result_ptr = NULL;
  object->__isset_result_ptr = FALSE;
}

static void 
simple_arr_comp_mat_multiply_args_finalize (GObject *object)
{
  SimpleArrCompMatMultiplyArgs *tobject = SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->array != NULL)
  {
    thrift_string_free(tobject->array);
    tobject->array = NULL;
  }
  if (tobject->matrix != NULL)
  {
    thrift_string_free(tobject->matrix);
    tobject->matrix = NULL;
  }
  if (tobject->dimension != NULL)
  {
    g_object_unref(tobject->dimension);
    tobject->dimension = NULL;
  }
  if (tobject->result_ptr != NULL)
  {
    thrift_string_free(tobject->result_ptr);
    tobject->result_ptr = NULL;
  }
}

static void
simple_arr_comp_mat_multiply_args_class_init (SimpleArrCompMatMultiplyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_mat_multiply_args_read;
  struct_class->write = simple_arr_comp_mat_multiply_args_write;

  gobject_class->finalize = simple_arr_comp_mat_multiply_args_finalize;
  gobject_class->get_property = simple_arr_comp_mat_multiply_args_get_property;
  gobject_class->set_property = simple_arr_comp_mat_multiply_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_ARRAY,
     g_param_spec_boxed ("array",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_MATRIX,
     g_param_spec_boxed ("matrix",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_LENGTH,
     g_param_spec_int ("length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_DIMENSION,
     g_param_spec_object ("dimension",
                         NULL,
                         NULL,
                         TYPE_TUPLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_ARGS_RESULT_PTR,
     g_param_spec_boxed ("result_ptr",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
simple_arr_comp_mat_multiply_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompMatMultiplyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_mat_multiply_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompMatMultiplyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_mat_multiply_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompMatMultiplyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompMatMultiplyResultProperties
{
  PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_RESULT_0,
  PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_RESULT_OUCH
};

/* reads a simple_arr_comp_mat_multiply_result object */
static gint32
simple_arr_comp_mat_multiply_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompMatMultiplyResult * this_object = SIMPLE_ARR_COMP_MAT_MULTIPLY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (TYPE_CALL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_mat_multiply_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompMatMultiplyResult * this_object = SIMPLE_ARR_COMP_MAT_MULTIPLY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompMatMultiplyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_mat_multiply_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  SimpleArrCompMatMultiplyResult *self = SIMPLE_ARR_COMP_MAT_MULTIPLY_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_mat_multiply_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  SimpleArrCompMatMultiplyResult *self = SIMPLE_ARR_COMP_MAT_MULTIPLY_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_mat_multiply_result_instance_init (SimpleArrCompMatMultiplyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
simple_arr_comp_mat_multiply_result_finalize (GObject *object)
{
  SimpleArrCompMatMultiplyResult *tobject = SIMPLE_ARR_COMP_MAT_MULTIPLY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
simple_arr_comp_mat_multiply_result_class_init (SimpleArrCompMatMultiplyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_mat_multiply_result_read;
  struct_class->write = simple_arr_comp_mat_multiply_result_write;

  gobject_class->finalize = simple_arr_comp_mat_multiply_result_finalize;
  gobject_class->get_property = simple_arr_comp_mat_multiply_result_get_property;
  gobject_class->set_property = simple_arr_comp_mat_multiply_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_MAT_MULTIPLY_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         TYPE_CALL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
simple_arr_comp_mat_multiply_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompMatMultiplyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_mat_multiply_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompMatMultiplyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_mat_multiply_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompMatMultiplyResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompWordCountArgsProperties
{
  PROP_SIMPLE_ARR_COMP_WORD_COUNT_ARGS_0,
  PROP_SIMPLE_ARR_COMP_WORD_COUNT_ARGS_STORY,
  PROP_SIMPLE_ARR_COMP_WORD_COUNT_ARGS_LENGTH
};

/* reads a simple_arr_comp_word_count_args object */
static gint32
simple_arr_comp_word_count_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompWordCountArgs * this_object = SIMPLE_ARR_COMP_WORD_COUNT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->story != NULL)
          {
            g_free(this_object->story);
            this_object->story = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->story = g_byte_array_new();
          g_byte_array_append (this_object->story, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_story = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_word_count_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompWordCountArgs * this_object = SIMPLE_ARR_COMP_WORD_COUNT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompWordCountArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "story", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->story)->data, ((GByteArray *) this_object->story)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "length", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->length, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_word_count_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  SimpleArrCompWordCountArgs *self = SIMPLE_ARR_COMP_WORD_COUNT_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_WORD_COUNT_ARGS_STORY:
      if (self->story != NULL)
        g_byte_array_unref (self->story);
      self->story = g_value_dup_boxed (value);
      self->__isset_story = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_WORD_COUNT_ARGS_LENGTH:
      self->length = g_value_get_int (value);
      self->__isset_length = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_word_count_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  SimpleArrCompWordCountArgs *self = SIMPLE_ARR_COMP_WORD_COUNT_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_WORD_COUNT_ARGS_STORY:
      g_value_set_boxed (value, self->story);
      break;

    case PROP_SIMPLE_ARR_COMP_WORD_COUNT_ARGS_LENGTH:
      g_value_set_int (value, self->length);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_word_count_args_instance_init (SimpleArrCompWordCountArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->story = NULL;
  object->__isset_story = FALSE;
  object->length = 0;
  object->__isset_length = FALSE;
}

static void 
simple_arr_comp_word_count_args_finalize (GObject *object)
{
  SimpleArrCompWordCountArgs *tobject = SIMPLE_ARR_COMP_WORD_COUNT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->story != NULL)
  {
    thrift_string_free(tobject->story);
    tobject->story = NULL;
  }
}

static void
simple_arr_comp_word_count_args_class_init (SimpleArrCompWordCountArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_word_count_args_read;
  struct_class->write = simple_arr_comp_word_count_args_write;

  gobject_class->finalize = simple_arr_comp_word_count_args_finalize;
  gobject_class->get_property = simple_arr_comp_word_count_args_get_property;
  gobject_class->set_property = simple_arr_comp_word_count_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_WORD_COUNT_ARGS_STORY,
     g_param_spec_boxed ("story",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_WORD_COUNT_ARGS_LENGTH,
     g_param_spec_int ("length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
simple_arr_comp_word_count_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompWordCountArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_word_count_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompWordCountArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_word_count_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompWordCountArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompWordCountResultProperties
{
  PROP_SIMPLE_ARR_COMP_WORD_COUNT_RESULT_0,
  PROP_SIMPLE_ARR_COMP_WORD_COUNT_RESULT_SUCCESS,
  PROP_SIMPLE_ARR_COMP_WORD_COUNT_RESULT_OUCH
};

/* reads a simple_arr_comp_word_count_result object */
static gint32
simple_arr_comp_word_count_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompWordCountResult * this_object = SIMPLE_ARR_COMP_WORD_COUNT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (TYPE_CALL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_word_count_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompWordCountResult * this_object = SIMPLE_ARR_COMP_WORD_COUNT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompWordCountResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_word_count_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  SimpleArrCompWordCountResult *self = SIMPLE_ARR_COMP_WORD_COUNT_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_WORD_COUNT_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_WORD_COUNT_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_word_count_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  SimpleArrCompWordCountResult *self = SIMPLE_ARR_COMP_WORD_COUNT_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_WORD_COUNT_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_SIMPLE_ARR_COMP_WORD_COUNT_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_word_count_result_instance_init (SimpleArrCompWordCountResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
simple_arr_comp_word_count_result_finalize (GObject *object)
{
  SimpleArrCompWordCountResult *tobject = SIMPLE_ARR_COMP_WORD_COUNT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
simple_arr_comp_word_count_result_class_init (SimpleArrCompWordCountResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_word_count_result_read;
  struct_class->write = simple_arr_comp_word_count_result_write;

  gobject_class->finalize = simple_arr_comp_word_count_result_finalize;
  gobject_class->get_property = simple_arr_comp_word_count_result_get_property;
  gobject_class->set_property = simple_arr_comp_word_count_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_WORD_COUNT_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_WORD_COUNT_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         TYPE_CALL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
simple_arr_comp_word_count_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompWordCountResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_word_count_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompWordCountResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_word_count_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompWordCountResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompSortArrayArgsProperties
{
  PROP_SIMPLE_ARR_COMP_SORT_ARRAY_ARGS_0,
  PROP_SIMPLE_ARR_COMP_SORT_ARRAY_ARGS_NUM_ARRAY,
  PROP_SIMPLE_ARR_COMP_SORT_ARRAY_ARGS_LENGTH
};

/* reads a simple_arr_comp_sort_array_args object */
static gint32
simple_arr_comp_sort_array_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompSortArrayArgs * this_object = SIMPLE_ARR_COMP_SORT_ARRAY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->num_array != NULL)
          {
            g_free(this_object->num_array);
            this_object->num_array = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->num_array = g_byte_array_new();
          g_byte_array_append (this_object->num_array, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_num_array = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_sort_array_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompSortArrayArgs * this_object = SIMPLE_ARR_COMP_SORT_ARRAY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompSortArrayArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_array", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->num_array)->data, ((GByteArray *) this_object->num_array)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "length", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->length, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_sort_array_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  SimpleArrCompSortArrayArgs *self = SIMPLE_ARR_COMP_SORT_ARRAY_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_SORT_ARRAY_ARGS_NUM_ARRAY:
      if (self->num_array != NULL)
        g_byte_array_unref (self->num_array);
      self->num_array = g_value_dup_boxed (value);
      self->__isset_num_array = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_SORT_ARRAY_ARGS_LENGTH:
      self->length = g_value_get_int (value);
      self->__isset_length = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_sort_array_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  SimpleArrCompSortArrayArgs *self = SIMPLE_ARR_COMP_SORT_ARRAY_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_SORT_ARRAY_ARGS_NUM_ARRAY:
      g_value_set_boxed (value, self->num_array);
      break;

    case PROP_SIMPLE_ARR_COMP_SORT_ARRAY_ARGS_LENGTH:
      g_value_set_int (value, self->length);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_sort_array_args_instance_init (SimpleArrCompSortArrayArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->num_array = NULL;
  object->__isset_num_array = FALSE;
  object->length = 0;
  object->__isset_length = FALSE;
}

static void 
simple_arr_comp_sort_array_args_finalize (GObject *object)
{
  SimpleArrCompSortArrayArgs *tobject = SIMPLE_ARR_COMP_SORT_ARRAY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->num_array != NULL)
  {
    thrift_string_free(tobject->num_array);
    tobject->num_array = NULL;
  }
}

static void
simple_arr_comp_sort_array_args_class_init (SimpleArrCompSortArrayArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_sort_array_args_read;
  struct_class->write = simple_arr_comp_sort_array_args_write;

  gobject_class->finalize = simple_arr_comp_sort_array_args_finalize;
  gobject_class->get_property = simple_arr_comp_sort_array_args_get_property;
  gobject_class->set_property = simple_arr_comp_sort_array_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_SORT_ARRAY_ARGS_NUM_ARRAY,
     g_param_spec_boxed ("num_array",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_SORT_ARRAY_ARGS_LENGTH,
     g_param_spec_int ("length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
simple_arr_comp_sort_array_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompSortArrayArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_sort_array_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompSortArrayArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_sort_array_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompSortArrayArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompSortArrayResultProperties
{
  PROP_SIMPLE_ARR_COMP_SORT_ARRAY_RESULT_0,
  PROP_SIMPLE_ARR_COMP_SORT_ARRAY_RESULT_SUCCESS,
  PROP_SIMPLE_ARR_COMP_SORT_ARRAY_RESULT_OUCH
};

/* reads a simple_arr_comp_sort_array_result object */
static gint32
simple_arr_comp_sort_array_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompSortArrayResult * this_object = SIMPLE_ARR_COMP_SORT_ARRAY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (TYPE_CALL_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_sort_array_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompSortArrayResult * this_object = SIMPLE_ARR_COMP_SORT_ARRAY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompSortArrayResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->success)->data, ((GByteArray *) this_object->success)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_sort_array_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  SimpleArrCompSortArrayResult *self = SIMPLE_ARR_COMP_SORT_ARRAY_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_SORT_ARRAY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_SORT_ARRAY_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_sort_array_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  SimpleArrCompSortArrayResult *self = SIMPLE_ARR_COMP_SORT_ARRAY_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_SORT_ARRAY_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SIMPLE_ARR_COMP_SORT_ARRAY_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_sort_array_result_instance_init (SimpleArrCompSortArrayResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
simple_arr_comp_sort_array_result_finalize (GObject *object)
{
  SimpleArrCompSortArrayResult *tobject = SIMPLE_ARR_COMP_SORT_ARRAY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
simple_arr_comp_sort_array_result_class_init (SimpleArrCompSortArrayResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_sort_array_result_read;
  struct_class->write = simple_arr_comp_sort_array_result_write;

  gobject_class->finalize = simple_arr_comp_sort_array_result_finalize;
  gobject_class->get_property = simple_arr_comp_sort_array_result_get_property;
  gobject_class->set_property = simple_arr_comp_sort_array_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_SORT_ARRAY_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_SORT_ARRAY_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         TYPE_CALL_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
simple_arr_comp_sort_array_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompSortArrayResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_sort_array_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompSortArrayResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_sort_array_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompSortArrayResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompNoOpArgsProperties
{
  PROP_SIMPLE_ARR_COMP_NO_OP_ARGS_0,
  PROP_SIMPLE_ARR_COMP_NO_OP_ARGS_NUM_ARRAY,
  PROP_SIMPLE_ARR_COMP_NO_OP_ARGS_LENGTH
};

/* reads a simple_arr_comp_no_op_args object */
static gint32
simple_arr_comp_no_op_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompNoOpArgs * this_object = SIMPLE_ARR_COMP_NO_OP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->num_array != NULL)
          {
            g_free(this_object->num_array);
            this_object->num_array = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->num_array = g_byte_array_new();
          g_byte_array_append (this_object->num_array, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_num_array = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_no_op_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompNoOpArgs * this_object = SIMPLE_ARR_COMP_NO_OP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompNoOpArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_array", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->num_array)->data, ((GByteArray *) this_object->num_array)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "length", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->length, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_no_op_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  SimpleArrCompNoOpArgs *self = SIMPLE_ARR_COMP_NO_OP_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_NO_OP_ARGS_NUM_ARRAY:
      if (self->num_array != NULL)
        g_byte_array_unref (self->num_array);
      self->num_array = g_value_dup_boxed (value);
      self->__isset_num_array = TRUE;
      break;

    case PROP_SIMPLE_ARR_COMP_NO_OP_ARGS_LENGTH:
      self->length = g_value_get_int (value);
      self->__isset_length = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_no_op_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  SimpleArrCompNoOpArgs *self = SIMPLE_ARR_COMP_NO_OP_ARGS (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_NO_OP_ARGS_NUM_ARRAY:
      g_value_set_boxed (value, self->num_array);
      break;

    case PROP_SIMPLE_ARR_COMP_NO_OP_ARGS_LENGTH:
      g_value_set_int (value, self->length);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_no_op_args_instance_init (SimpleArrCompNoOpArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->num_array = NULL;
  object->__isset_num_array = FALSE;
  object->length = 0;
  object->__isset_length = FALSE;
}

static void 
simple_arr_comp_no_op_args_finalize (GObject *object)
{
  SimpleArrCompNoOpArgs *tobject = SIMPLE_ARR_COMP_NO_OP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->num_array != NULL)
  {
    thrift_string_free(tobject->num_array);
    tobject->num_array = NULL;
  }
}

static void
simple_arr_comp_no_op_args_class_init (SimpleArrCompNoOpArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_no_op_args_read;
  struct_class->write = simple_arr_comp_no_op_args_write;

  gobject_class->finalize = simple_arr_comp_no_op_args_finalize;
  gobject_class->get_property = simple_arr_comp_no_op_args_get_property;
  gobject_class->set_property = simple_arr_comp_no_op_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_NO_OP_ARGS_NUM_ARRAY,
     g_param_spec_boxed ("num_array",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_NO_OP_ARGS_LENGTH,
     g_param_spec_int ("length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
simple_arr_comp_no_op_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompNoOpArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_no_op_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompNoOpArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_no_op_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompNoOpArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _SimpleArrCompNoOpResultProperties
{
  PROP_SIMPLE_ARR_COMP_NO_OP_RESULT_0,
  PROP_SIMPLE_ARR_COMP_NO_OP_RESULT_SUCCESS
};

/* reads a simple_arr_comp_no_op_result object */
static gint32
simple_arr_comp_no_op_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SimpleArrCompNoOpResult * this_object = SIMPLE_ARR_COMP_NO_OP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
simple_arr_comp_no_op_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SimpleArrCompNoOpResult * this_object = SIMPLE_ARR_COMP_NO_OP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SimpleArrCompNoOpResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->success)->data, ((GByteArray *) this_object->success)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
simple_arr_comp_no_op_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  SimpleArrCompNoOpResult *self = SIMPLE_ARR_COMP_NO_OP_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_NO_OP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
simple_arr_comp_no_op_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  SimpleArrCompNoOpResult *self = SIMPLE_ARR_COMP_NO_OP_RESULT (object);

  switch (property_id)
  {
    case PROP_SIMPLE_ARR_COMP_NO_OP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
simple_arr_comp_no_op_result_instance_init (SimpleArrCompNoOpResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
}

static void 
simple_arr_comp_no_op_result_finalize (GObject *object)
{
  SimpleArrCompNoOpResult *tobject = SIMPLE_ARR_COMP_NO_OP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
}

static void
simple_arr_comp_no_op_result_class_init (SimpleArrCompNoOpResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = simple_arr_comp_no_op_result_read;
  struct_class->write = simple_arr_comp_no_op_result_write;

  gobject_class->finalize = simple_arr_comp_no_op_result_finalize;
  gobject_class->get_property = simple_arr_comp_no_op_result_get_property;
  gobject_class->set_property = simple_arr_comp_no_op_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIMPLE_ARR_COMP_NO_OP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
simple_arr_comp_no_op_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SimpleArrCompNoOpResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) simple_arr_comp_no_op_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SimpleArrCompNoOpResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) simple_arr_comp_no_op_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SimpleArrCompNoOpResultType",
                                   &type_info, 0);
  }

  return type;
}

